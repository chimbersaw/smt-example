# SMT solver example

## Run

```shell
pip install -r requirements.txt
python3 main.py
```

Лучше запускать из `IDE`([например](https://www.jetbrains.com/pycharm/)).

## Решение

В `main.py` находится основная программа для решения задачи. В папке `samples` можно найти примеры входных и выходных данных и даже картинки. В изначальном условии пример вывода 1 и пример ввода 2 некорректны (но очевидно как их поправить).

Решение использует `API` `SMT`-солвера `z3` для питона.

Используется теория линейной целочисленной арифметики, а конкретно сравнения на больше/меньше/равно между интами.

Термин вершина = элемент данного множества.

Описание решений подзадач:
* Антисимметричность нарушается при существовании цикла. Ровно его нам и найдёт солвер, если в него запихнуть изначальные отношения. Предикаты вида `p0` используются для получения от солвера нарушающих условий при вызове `unsat_core`. Вывожу все вершины, участвующие в "плохом" отношении. Если хочется, то их можно выводить в порядке обхода этого самого цикла, но в условии такое не требуется.
* Дальше везде используется функция `find_maximums`. Она принимает множество еще живых вершин и возвращает максимум, при этом удаляя их из переданного множества. Для этого заводится отдельная переменная, отвечающая максимуму, и добавляются соответсвующие ограничения. Дальше на каждой итерации цикла находится значение `x` как инта, и запоминаются в результирующий сет вершины с таким же найденным значением инта (при этом удаляясь из общего массива еще живых вершин). Когда максимумов больше нет, функция заканчивает свою работу.
* Наличие `while True` важно: пусть у нас есть `a < b` и `a < c`. Тогда в интах солвер мог найти решение `a = 1`, `b = 2`, `c = 3`. После одной итерации цикла мы узнаем только про `c`, как максимального по интовому значению. Убрав его, сможем найти и `b`, которое на самом деле тоже является максимумом.
* С помощью `find_maximums` все вершины разбиваются на уровни: на нулевом уровне максимумы всего множества, на каждом следующем уровне максимумы изначального множества без предыдущих уровней. Таким образом, на последнем уровне будут минимумы.
* не будут

## References

1. https://docs.google.com/document/d/1RAfWvr419yHrZGYlLelDvz6rPnZT96JrDxaZpXBkepQ
2. https://github.com/Z3Prover/z3/tree/master/examples/python
3. https://sat-smt.codes/SAT_SMT_by_example.pdf
