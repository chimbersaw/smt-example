# SMT solver example

## Run

```shell
pip install -r requirements.txt
python3 main.py
```

Лучше запускать из `IDE`([например](https://www.jetbrains.com/pycharm/)).

## Решение

В `main.py` находится основная программа для решения задачи. В папке `samples` можно найти примеры входных и выходных данных и даже картинки. В изначальном условии пример вывода 1 и пример ввода 2 некорректны (но очевидно как их поправить).

Решение использует `API` `SMT`-солвера `z3` для питона.

Используется теория линейной целочисленной арифметики, а конкретно сравнения на больше/меньше/равно между интами.

Термин `вершина` = `элемент заданного множества`.

Описание решений подзадач:
* Антисимметричность нарушается при существовании цикла. Ровно его нам и найдёт солвер, если в него запихнуть изначальные отношения. Предикаты вида `p0` используются для получения от солвера нарушающих условий при вызове `unsat_core`. Вывожу все вершины, участвующие в "плохом" отношении. Если хочется, то их можно выводить в порядке обхода этого самого цикла, но в условии такое не требуется.
* Дальше используется функция `find_extremums`. Она принимает множество еще живых вершин и возвращает экстремумы (максимумы или минимумы в зависимости от переданного параметра), при этом удаляя их из переданного множества. Для этого заводится отдельная переменная `x`, отвечающая экстремуму, и добавляются соответсвующие ограничения. Дальше на каждой итерации цикла находится значение `x` как инта, и запоминаются в результирующий сет вершины с таким же найденным значением инта (при этом удаляясь из общего массива еще живых вершин). Когда экстремумов больше нет, функция заканчивает свою работу.
* Наличие `while True` важно: пусть у нас есть `a < b` и `a < c`. Тогда в интах солвер мог найти решение `a = 1`, `b = 2`, `c = 3`. После одной итерации цикла мы узнаем только про `c`, как максимального по интовому значению. Только убрав его, сможем найти и `b`, которое на самом деле тоже является максимумом.
* В функции `find_levels` с помощью `find_extremums` все вершины разбиваются на уровни (отдельно по максимумам и по минимумам): на нулевом уровне максимумы/минимумы всего множества, на каждом следующем уровне максимумы/минимумы изначального множества без предыдущих уровней.
* Для вывода ответа максимумы и минимумы мы уже явно нашли.
* Если на одном уровне есть хотя бы две вершины, то они несравнимы, то есть линейного порядка нет. Если на каждом уровне по одной вершине, то порядок очевиден. Таким образом, для существования линейного порядка нужно проверить, что размер каждого уровня один.
* Транзитивное сокращение строится путём выкидывания из изначального отношения "лишних" пар. Формально таких `aRb`, что существует `aRc` и `cRb` для некоторого `c`. Утверждается, что это эквивалентно тому факту, что уровни `a` и `b` и по максимумам, и по минимумам, отличаются больше, чем на один, то есть между этими вершинами кто-то обязательно есть. Формальное доказательство этого факта остаётся читателю как упражнение.

## References

1. https://docs.google.com/document/d/1RAfWvr419yHrZGYlLelDvz6rPnZT96JrDxaZpXBkepQ
2. https://github.com/Z3Prover/z3/tree/master/examples/python
3. https://sat-smt.codes/SAT_SMT_by_example.pdf
